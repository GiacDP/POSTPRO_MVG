PROGRAM wallspec
!
! This program evaluates the Power Spectral Density of 
! the wall pressure from the slicexz generated by STREAmS-2.
!
! ATT. It works (tested) with a single xz slice stored in the files.
!      num_jslice = 1
!
! ATT. readind_zmapspec*.dat contains the spectra at locations from input 
!      file and considers all the locations as being along the 
!      spanwise direction. Space coordinate is z!
!
! INPUT FILES
!  ./input_spec.dat
!    nbx, nby, nbz   Streamwise/Wall-normal/Spanwise number of blocks
!    ng              Number of ghost nodes
!    ibstart         Minimum streamwise block number considered
!    kbstart             "   spanwise     "     "      " 
!    jmax            Maximum wall-normal coordinate considered
!    m               Number of samples in segment for Pwelch (==> fmin)
!    fmin            (only if m<0) Minimum frequency considered in spectra (==> m)
!    i_avspan        Flag for spanwise-averaged spectra
!    nspecsec        Number of sections along spanwise direction for spectral analysis
!    i_readindex     Flag for spectra at spanwise indices indicated from file (./list_indices.dat)
!    IF (nspecsec /= 0) jsec(1:nspecsec) Spanwise indices if nspecsec > 0
!
!    IF (i_readindex /= 0) './list_indices.dat' List of indices for spectral analysis.
!      nxmaxt, nzmaxt  Total number of streamwise/spanwise number of points in slices
!      nbxt, nbzt      Number of        "           "      blocks 
!      ngt             Number of ghost nodes
!      nread           Number of indices to read
!      i_read(1:nread), k_read(1:nread)  Streamwise/Spanwise indices to read
!
!  ./slicexz_'//chchi//'_000_'//chchk//'.bin    xz slice blocks from simulation
!
!  ./dxg.dat, ./dyg.dat, ./dzg.dat              Coords files from simulation
!
!
! OUTPUT FILES
! 
! IF (i_avspan /= 0) THEN
! 
!  ./POSTPRO_SPEC/prms_xz_avspanspec_//chx//.dat
!    x, sqrt(prmspec): streamwise coord, local pressure standard deviation
! 
!   ./POSTPRO_SPEC/spanav_xz_spec_//chspec//.dat
!    Spanwise-averaged spectra at single streamwise sections.
!    ff,spec_av,spec_av/prmspec: frequency, pressure spectrum, pressure spectrum normalised by local variance
!  
!  ./POSTPRO_SPEC/spanav_xz_mapspec_//chx//.dat
!     Spanwise-averaged spectral map for Tecplot containing 
!      1: x, 2: log10(f), 
!      3: premultiplied pressure spectra,
!      4: premultiplied pressure spectra normalised by local variance
! 
! IF (nspecsec /= 0 ) THEN
! 
!   ./POSTPRO_SPEC/mapspec_k//chk//_//chx//.dat
!     Spectral map at precise spanwise sections for Tecplot containing 
!      1: x, 2: log10(f), 
!      3: premultiplied pressure spectra,
!      4: premultiplied pressure spectra normalised by local variance
! 
! IF (i_readindex == 1) THEN
! 
!     ./POSTPRO_SPEC/psignal_i//chread_i//_k//chread_k//.dat
!      time, pw_read: time, pressure signal of probes i,k
! 
!    ./POSTPRO_SPEC/readind_zmapspec_//chx//.dat
!     Spectral map along spanwise indices read from input for Tecplot containing 
!      1: x, 2: log10(f), 
!      3: premultiplied pressure spectra,
!      4: premultiplied pressure spectra normalised by local variance
!
! 29/01/2024 G. Della Posta (original: M. Bernardini)
!

USE mpi

IMPLICIT NONE

!--------------------------------------------------------------------------

INTEGER :: nbx, nby, nbz, ng, ibstart, m
INTEGER :: nxmax, nymax, nzmax, nx, ny, nz
INTEGER :: i, j, k, kb, itime, l, n, kseg, lr, kr, llr, ltr
INTEGER :: kbstart, kbend, i_avspan, nspecsec, i_readindex 
INTEGER :: nxmaxt, nbxt, nzmaxt, nbzt, ngt, nread
INTEGER :: nrank, nproc, num_jslice, num_record
INTEGER :: ierr, iermpi, istatus, icyc
INTEGER :: nread_loc, nspecsec_loc

INTEGER, ALLOCATABLE, DIMENSION(:) :: jgloblist, icycvec
INTEGER, ALLOCATABLE, DIMENSION(:) :: ksec, i_read, k_read, ik_read
INTEGER, ALLOCATABLE, DIMENSION(:) :: i_loc_global, k_loc_global

REAL :: fmin, time, ttot, ff, df, dt

REAL, ALLOCATABLE, DIMENSION(:) :: x,y,z
REAL, ALLOCATABLE, DIMENSION(:) :: pmean,prms,prmspec
REAL, ALLOCATABLE, DIMENSION(:) :: prmspec_sec, prmspec_read
REAL, ALLOCATABLE, DIMENSION(:) :: timevec, spec

REAL, ALLOCATABLE, DIMENSION(:,:) :: pw_read, spec_read
REAL, ALLOCATABLE, DIMENSION(:,:) :: spec_av

REAL, ALLOCATABLE, DIMENSION(:,:,:) :: pw, spec_sec

REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: slicexz

LOGICAL :: masterproc, ist, il_read

CHARACTER(3) :: chx,chy,chz, chchk
CHARACTER(4) :: chspec, chk
CHARACTER(5) :: chread_i, chread_k

!--------------------------------------------------------------------------

CALL MPI_INIT(ierr)
CALL MPI_COMM_RANK(mpi_comm_world,nrank,ierr)
CALL MPI_COMM_SIZE(mpi_comm_world,nproc,ierr)

masterproc = .false.
IF (nrank==0) masterproc = .true.

IF (masterproc) WRITE(*,*) '==============================================='
IF (masterproc) WRITE(*,*) 'Start of wallspec.'
IF (masterproc) WRITE(*,*) '==============================================='

!--------------------------------------------------------------------------
! Read input
IF (masterproc) THEN
  OPEN(666, file='./input_spec.dat', ACTION='read', STATUS='old')
  READ(666,*) !nbx, nby, nbz, ng, ibstart
  READ(666,*) nbx, nby, nbz, ng, ibstart             
  READ(666,*) ! m, fmin
  READ(666,*) m, fmin                               
  READ(666,*) !i_avspan, nspecsec, i_readindex
  READ(666,*) i_avspan, nspecsec, i_readindex      
  IF (nspecsec /= 0) THEN
    ALLOCATE(ksec(nspecsec))
    READ(666,*) ! (ksec(k), k = 1, nspecsec)   
    READ(666,*) (ksec(k), k = 1, nspecsec)         
  ENDIF
  CLOSE(666)

  IF (i_readindex /= 0) THEN
    OPEN(666,FILE='./list_indices.dat', ACTION='read', STATUS='old')
    READ(666,*) 
    READ(666,*) nxmaxt, nbxt, nzmaxt, nbzt, ngt, nread
    READ(666,*) 
    ALLOCATE(i_read(nread), k_read(nread))
    DO lr = 1, nread
      READ(666,*) i_read(lr), k_read(lr)
    ENDDO
    CLOSE(666)
  ENDIF

  WRITE(*,*) 'Read input files.'

ENDIF

CALL MPI_BCAST(nbx,        1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(nby,        1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(nbz,        1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(ng,         1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(ibstart,    1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(m,          1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(fmin,       1,mpi_real8,  0,mpi_comm_world,ierr)
CALL MPI_BCAST(i_avspan,   1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(nspecsec,   1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(i_readindex,1,mpi_integer,0,mpi_comm_world,ierr)

IF (i_readindex /= 0) THEN
  CALL MPI_BCAST(nread,      1,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(nxmaxt,     1,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(nbxt,       1,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(nzmaxt,     1,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(nbzt,       1,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(ngt,        1,mpi_integer,0,mpi_comm_world,ierr)
  IF (.NOT.masterproc) ALLOCATE(i_read(nread), k_read(nread))
  CALL MPI_BCAST(i_read, nread,mpi_integer,0,mpi_comm_world,ierr)
  CALL MPI_BCAST(k_read, nread,mpi_integer,0,mpi_comm_world,ierr)
ENDIF
 
IF (nspecsec /= 0) THEN
  IF (.NOT.masterproc) ALLOCATE(ksec(nspecsec))
  CALL MPI_BCAST(ksec, nspecsec,mpi_integer,0,mpi_comm_world,ierr)
ENDIF

!--------------------------------------------------------------------------
! Count number of records

WRITE(chchk, '(I3.3)') ibstart

IF (masterproc) THEN

  OPEN(135,file='./slicexz_'//chchk//'_000_000.bin',form='unformatted', STATUS='old', ACTION='read')
  READ(135) icyc,time
  READ(135) nxmax, nymax, nzmax
  READ(135) num_jslice
  ALLOCATE(jgloblist(num_jslice))
  BACKSPACE(135)
  READ(135) num_jslice,(jgloblist(l),l=1,num_jslice)
  CLOSE(135)
 
  IF ((i_readindex /= 0) .AND. ((nxmaxt /= nxmax) .OR. (nbxt /= nbx) .OR. &
     &  (nxmaxt /= nxmax) .OR. (nbzt /= nbz) .OR. (ngt /= ng))) THEN
    WRITE(*,*) 'list_indices.dat contains not conformal data.'
    WRITE(*,*) 'nxmaxt, nbxt, nzmaxt, nbzt, ngt = ', nxmaxt, nbxt, nzmaxt, nbzt, ngt
    WRITE(*,*) 'nxmax,   nbx,  nzmax,  nbz,  ng = ', nxmax, nbx, nzmax, nbz, ng
    RETURN
  ENDIF
 
  num_record = 0
  OPEN(135,file='./slicexz_'//chchk//'_000_000.bin',form='unformatted', STATUS='old', ACTION='read')
  DO
    READ(135,iostat=istatus) icyc,time
    IF (istatus==0) THEN
      num_record = num_record+1
      READ(135)
      READ(135)
      READ(135)
      READ(135)
    ELSE
      EXIT
    ENDIF
  ENDDO
  CLOSE(135)
  ALLOCATE(timevec(num_record))
  ALLOCATE(icycvec(num_record))
  OPEN(135,file='./slicexz_'//chchk//'_000_000.bin',form='unformatted', STATUS='old', ACTION='read')
  DO itime=1,num_record
    READ(135) icycvec(itime),timevec(itime)
    READ(135)
    READ(135)
    READ(135)
    READ(135)
  ENDDO
  CLOSE(135)

ENDIF

!--------------------------------------------------------------------------
! BCAST of PARAMETERs

CALL MPI_BCAST(nxmax,     1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(nymax,     1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(nzmax,     1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(num_jslice,1,mpi_integer,0,mpi_comm_world,ierr)
CALL MPI_BCAST(num_record,1,mpi_integer,0,mpi_comm_world,ierr)
IF (.not. masterproc) THEN
  ALLOCATE(jgloblist(num_jslice))
  ALLOCATE(timevec(num_record))
  ALLOCATE(icycvec(num_record))
ENDIF
CALL MPI_BCAST(jgloblist,num_jslice,mpi_integer,0, & 
              & mpi_comm_world,ierr)
CALL MPI_BCAST(icycvec,  num_record,mpi_integer,0, &
              & mpi_comm_world,ierr)
CALL MPI_BCAST(timevec,  num_record,mpi_real8,  0, &
              & mpi_comm_world,ierr)

!--------------------------------------------------------------------------
! Grid 

ALLOCATE(x(nxmax),y(nymax),z(nzmax))

IF (masterproc) THEN
  OPEN(18,file='./dxg.dat', STATUS='old', ACTION='read')
  DO i=1,nxmax
    READ(18,*) x(i)
  ENDDO
  CLOSE(18)
  OPEN(18,file='./dyg.dat', STATUS='old', ACTION='read')
  DO j=1,nymax
    READ(18,*) y(j)
  ENDDO
  CLOSE(18)
  OPEN(18,file='./dzg.dat', STATUS='old', ACTION='read')
  DO k=1,nzmax
    READ(18,*) z(k)
  ENDDO
  CLOSE(18)
ENDIF

CALL MPI_BCAST(x,nxmax,mpi_real8,0,mpi_comm_world,ierr)
CALL MPI_BCAST(y,nymax,mpi_real8,0,mpi_comm_world,ierr)
CALL MPI_BCAST(z,nzmax,mpi_real8,0,mpi_comm_world,ierr)

IF (masterproc) WRITE(*,*) 'nxmax, nymax, nzmax:', nxmax,nymax,nzmax
IF (masterproc) WRITE(*,*) 'num_jslice:         ', num_jslice
IF (masterproc) WRITE(*,*) 'jlist:              ', (jgloblist(l),l=1,num_jslice)
IF (masterproc) WRITE(*,*) 'num_record:         ', num_record

nx = nxmax/nbx
ny = nymax/nby
nz = nzmax/nbz
n  = num_record 

!--------------------------------------------------------------------------
! Evaluate spectra parameters

dt = (timevec(n)-timevec(1))/(n-1)
IF (m > 0) THEN
  kseg = n/m-1
  ttot = 2.*m*dt
  df   = 1./ttot
  fmin = df
ELSE 
  kseg = FLOOR(n*dt*2.*fmin)-1
  m    = FLOOR(n/(kseg+1.));
  IF (n < 1/dt/fmin) THEN
    IF (masterproc) WRITE(*,*) 'With this fmin, signal is shorter than segment!'
    kseg = 1
    m    = FLOOR(n/(kseg+1.))
  ENDIF
  ttot = 2.*m*dt
  df   = 1./ttot
ENDIF      
           
IF (masterproc) THEN
  WRITE(*,*) 'Computing spectrum with fifty percent of overlap'
  WRITE(*,*) 'Number of segments:', kseg
  WRITE(*,*) 'Number of points for each partition:', m
  WRITE(*,*) 'Telaps1, timevec, dt:', timevec(1),timevec(n),dt
  WRITE(*,*) 'df, fmin (file or imposed):', df, fmin
  WRITE(*,*) 'fmax:', 0.5/dt
ENDIF

!--------------------------------------------------------------------------
! Allocate vars

ALLOCATE(pmean(nx))
ALLOCATE(prms(nx))
ALLOCATE(prmspec(nx))
ALLOCATE(spec(0:m))
ALLOCATE(spec_av(0:m,nx))
ALLOCATE(pw(nx,nz,n))

IF (i_readindex /= 0) THEN
  ALLOCATE(pw_read(nread,n))
  ALLOCATE(prmspec_read(nx))
  ALLOCATE(spec_read(nread,0:m))
  ALLOCATE(ik_read(nread))
  ALLOCATE(i_loc_global(nread))
  ALLOCATE(k_loc_global(nread))
  pw_read      = 0.
  prmspec_read = 0.
  spec_read    = 0.
  ik_read      = 0
  i_loc_global = 0
  k_loc_global = 0
ENDIF

IF (nspecsec /= 0) THEN
  ALLOCATE(prmspec_sec(nx))
  ALLOCATE(spec_sec(nspecsec,0:m,nx))
  prmspec_sec  = 0.
  spec_sec     = 0.
ENDIF

!--------------------------------------------------------------------------
! Read data and compute spectra of wall pressure.

ALLOCATE(slicexz(1-ng:nx+ng,num_jslice,1-ng:nz+ng,6))

kbstart = 0
kbend   = nbz-1
lr      = 0
kr      = 0

spec_av  = 0. ! Single spanwise- and time-averaged spectra

IF (masterproc) WRITE(*,*) 'Start with reading + spectra.'

DO kb = kbstart, kbend

  IF (masterproc) WRITE(*,*) kb
  WRITE(chx,'(I3.3)') nrank+ibstart
  WRITE(chy,'(I3.3)') 0
  WRITE(chz,'(I3.3)') kb
  OPEN(135,file='./slicexz_'//chx//'_'//chy//'_'//chz//'.bin', & 
         & form='unformatted',status='old',action='read')
 
  ! Read all records
  DO itime = 1, n
    READ(135) icyc, time
    READ(135)
    READ(135)
    READ(135)
    READ(135) slicexz
    DO k=1,nz
      DO i=1,nx
        pw(i,k,itime) = slicexz(i,1,k,1)*slicexz(i,1,k,6)
      ENDDO
    ENDDO
  ENDDO
  
  ! Compute and store spectra
 
  DO k=1,nz
 
    IF (nspecsec /= 0) THEN 
      IF (ANY(ksec==k+kb*nz)) THEN
        ist = .TRUE.
        kr  = kr + 1 
      ENDIF
    ENDIF
 
    IF (i_readindex == 1) THEN
      llr = 0
      ik_read = 0      
      IF (ANY(k_read == (k+kb*nz))) THEN
        il_read = .TRUE.
        DO ltr = 1, nread
          IF (k_read(ltr) == (k+kb*nz)) THEN
            llr = llr + 1
            ik_read(llr) = i_read(ltr)
          ENDIF
        ENDDO
      ELSE 
        il_read = .FALSE.
      ENDIF
    ENDIF
 
    DO i=1,nx
 
      ! Evaluate Welch
      CALL welch(pw(i,k,1:n),spec(0:m),m,n,kseg)
 
      ! Spanwise-averaged spectra
      IF (i_avspan == 1) THEN
        DO l=0,m
          spec_av(l,i) = spec_av(l,i)+spec(l)*dt
        ENDDO
      ENDIF
 
      ! Spectra at spanwise sections
      IF (nspecsec /= 0) THEN
        IF (ist) THEN  
          spec_sec(kr, 0:m, i) = spec(0:m)*dt
        ENDIF
      ENDIF
 
      ! Spectra at indices from file
      !WRITE(*,*) 'k, il_read = ', k, il_read
      IF (i_readindex == 1) THEN
        IF ((il_read) .AND. (ANY(ik_read == (i+(nrank+ibstart)*nx)))) THEN
          lr = lr + 1
          WRITE(*,*) nrank, lr, ik_read(1:3), i+(nrank+ibstart)*nx, k+kb*nz, i, k
          pw_read(lr,:)      = pw(i,k,:)
          spec_read(lr, 0:m) = spec(0:m)*dt
          i_loc_global(lr)   = i+(nrank+ibstart)*nx
          k_loc_global(lr)   = k+kb*nz
        ENDIF
      ENDIF
 
    ENDDO
  ENDDO
  
ENDDO

nspecsec_loc = kr ! Number of spectra at spanwise sections in the process' slice
nread_loc    = lr ! Number of spectra at reading locations in the process' slice

spec_av = spec_av/nz/(kbend-kbstart+1)

DEALLOCATE(slicexz)

CALL MPI_BARRIER(mpi_comm_world, iermpi)
IF (masterproc) WRITE(*,*) 'Done evaluating spectra.'
WRITE(*,*) 'Number of probes from file  in ', nrank, ' slice: ', nread_loc
WRITE(*,*) 'Number of probes from input in ', nrank, ' slice: ', nspecsec_loc
CALL MPI_BARRIER(mpi_comm_world, iermpi)

!--------------------------------------------------------------------------
! Write output

IF (i_avspan /= 0) THEN

 ! sigma_pwall
 OPEN(10,file='./POSTPRO_SPEC/prms_avspanspec_'//chx//'.dat')
 prmspec = 0.
 DO i=1,nx
  prmspec(i) = spec_av(m,i)*df ! l = m only once
  DO l=1,m-1 ! No l = 0
   prmspec(i) = prmspec(i)+2.*spec_av(l,i)*df ! Factor two is due to two-sided spectrum
  ENDDO
  WRITE(10,*) x(i+nx*(nrank+ibstart)), sqrt(prmspec(i)) 
 ENDDO
 CLOSE(10)

 ! Spanwise-averaged spectra along x (x by x)
 DO i=1,nx
  WRITE(chspec,'(I4.4)') i+nx*(nrank+ibstart)
  OPEN(12,file='./POSTPRO_SPEC/spanav_spec_'//chspec//'.dat')
  DO l=1,m
   ff = 0.5*l/dt/m
   WRITE(12,'(4ES20.10)') ff,spec_av(l,i),spec_av(l,i)/prmspec(i)
  ENDDO
  CLOSE(12)
 ENDDO
 
 ! Premultiplied spanwise-averaged streamwise spectral map
 OPEN(12,file='./POSTPRO_SPEC/spanav_mapspec_'//chx//'.dat')
 WRITE(12,*) 'zone i=',nx,', j=',m
 DO l=1,m
  DO i=1,nx
   ff = 0.5*l/dt/m
   WRITE(12,'(4ES20.10)') x(i+nx*(nrank+ibstart)),log10(ff),ff*spec_av(l,i),&
   &  ff*spec_av(l,i)/prmspec(i)
  ENDDO
 ENDDO
 CLOSE(12)

ENDIF

! Premultiplied streamwise spectral map at spanwise sections

IF (nspecsec /= 0 ) THEN

 DO kr = 1, nspecsec_loc
 
  ! Spanwise local prms
  prmspec_sec = 0.
  DO i = 1, nx
   prmspec_sec(i) = spec_sec(kr,m,i)*df 
   DO l=1,m-1 
    prmspec_sec(i) = prmspec_sec(i)+2.*spec_sec(kr,l,i)*df 
   ENDDO
  ENDDO
 
  ! Write map
  WRITE(chk, '(I4.4)') ksec(kr)
  OPEN(12,file='./POSTPRO_SPEC/mapspec_k'//chk//'_'//chx//'.dat')
  WRITE(12,*) 'zone i=',nx,', j=',m
  DO l=1,m
   DO i=1,nx
    ff = 0.5*l/dt/m
    WRITE(12,'(4ES20.10)') x(i+nx*(nrank+ibstart)),log10(ff),  & 
                           & ff*spec_sec(kr,l,i),               &
                           & ff*spec_sec(kr,l,i)/prmspec_sec(i)
   ENDDO
  ENDDO
  CLOSE(12)
 
 ENDDO

ENDIF

IF (i_readindex == 1) THEN

 IF (nread_loc /= 0) THEN

   DO lr = 1, nread_loc
    ! Single time signal for read file
    WRITE(chread_i, '(I5.5)') i_loc_global(lr)
    WRITE(chread_k, '(I5.5)') k_loc_global(lr)
    OPEN(13,file='./POSTPRO_SPEC/psignal_i'//chread_i//'_k'//chread_k//'.dat')
    DO itime = 1, n
     WRITE(13,*) timevec(itime),pw_read(lr,itime)
    ENDDO
    CLOSE(13)

    ! Local prms
    prmspec_read(lr) = spec_read(lr,m)*df
    DO l=1,m-1
     prmspec_read(lr) = prmspec_read(lr)+2.*spec_read(lr,l)*df
    ENDDO
   ENDDO

   ! Write zmap
   OPEN(12,file='./POSTPRO_SPEC/readind_zmapspec_'//chx//'.dat')
   WRITE(12,*) 'zone i=',nread_loc,', j=',m
   DO l=1,m
    DO lr = 1, nread_loc
    ff = 0.5*l/dt/m
    WRITE(12,'(4ES20.10)') z(k_loc_global(lr)),log10(ff),&
                           & ff*spec_read(lr,l),                       &
                           & ff*spec_read(lr,l)/prmspec_read(lr)
    ENDDO
   ENDDO
   CLOSE(12)

 ENDIF

ENDIF

!--------------------------------------------------------------------------

CALL MPI_BARRIER(mpi_comm_world, iermpi)

IF (masterproc) WRITE(*,*) '==============================================='
IF (masterproc) WRITE(*,*) 'End of wallspec.'
IF (masterproc) WRITE(*,*) '==============================================='

CALL MPI_FINALIZE(iermpi)
 
!--------------------------------------------------------------------------

END PROGRAM wallspec
